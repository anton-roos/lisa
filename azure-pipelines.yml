trigger:
- main

stages:
# ===== CI: Build & publish artifact =====
- stage: Build
  displayName: Build (.NET 10 preview)
  jobs:
  - job: BuildJob
    pool: { name: Default }
    variables:
      solution: '**/*.sln'
      buildConfiguration: 'Release'
      NUGET_PACKAGES: 'C:\.nuget\packages'   # short path to avoid MAXPATH flakiness
    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET 10 preview SDK'
      inputs:
        version: '10.0.100-preview.6.25358.103'
        includePreviewVersions: true
    - powershell: dotnet --info

    # Optional but helps if prior partial restores exist
    - powershell: |
        try {
          dotnet nuget locals all --clear
        } catch {
          Write-Host "NuGet cache clear failed, continuing."
        }
      displayName: 'Clear dotnet nuget caches'

    - task: DotNetCoreCLI@2
      displayName: 'Restore'
      inputs:
        command: 'restore'
        projects: '$(solution)'
      env:
        NUGET_PACKAGES: '$(NUGET_PACKAGES)'
        DOTNET_ROLL_FORWARD_TO_PRERELEASE: '1'

    # Use dotnet msbuild to generate WebDeploy package (same args you had)
    - task: DotNetCoreCLI@2
      displayName: 'Build & Package (msbuild)'
      inputs:
        command: 'custom'
        custom: 'msbuild'
        projects: '$(solution)'
        arguments: >
          /p:Configuration=$(buildConfiguration)
          /p:DeployOnBuild=true
          /p:WebPublishMethod=Package
          /p:PackageAsSingleFile=true
          /p:SkipInvalidConfigurations=true
          /p:DesktopBuildPackageLocation="$(Build.ArtifactStagingDirectory)\WebApp.zip"
          /p:DeployIisAppPath="Default Web Site"
          /p:ExcludeFilesFromDeployment="appsettings.json"
          /p:SatelliteResourceLanguages="en"
          /p:PublishReadyToRun=false
          /p:PublishSingleFile=false
      env:
        NUGET_PACKAGES: '$(NUGET_PACKAGES)'
        DOTNET_ROLL_FORWARD_TO_PRERELEASE: '1'
    
    # Publish the package/artifacts so downstream deployment stages can download them
    - task: PublishPipelineArtifact@1
      displayName: 'Publish artifact: drop'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'drop'
        publishLocation: 'pipeline'

# ===== CD: SIT =====
- stage: Deploy_SIT
  displayName: Deploy to SIT
  dependsOn: Build
  jobs:
  - deployment: DeployToSIT
    environment: 'SIT'
    pool: { name: Default }
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: WindowsMachineFileCopy@2
            displayName: 'Copy package to target machine'
            inputs:
              SourcePath: '$(Pipeline.Workspace)\drop\WebApp.zip'
              MachineNames: 'sit-server.dceg.co.za'
              AdminUserName: 'dcegroup\svc-deploy'
              AdminPassword: '$(deploy_password)'
              TargetPath: 'C:\Temp\$(Build.BuildId)'

          - powershell: |
              $ErrorActionPreference = 'Stop'

              $pkgRemote = "C:\Temp\$($env:BUILD_BUILDID)\WebApp.zip"
              $siteName     = 'sit.dceg.co.za'
              $appPool      = 'sit.dceg.co.za'
              $hostHeader   = 'sit.dceg.co.za'
              $httpPort     = 80
              $enableHttps  = $false
              $httpsPort    = 443
              $thumb        = ''
              $physicalPath = 'C:\Sites\sit.dceg.co.za'

              $sec = ConvertTo-SecureString "$(deploy_password)" -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential ("dcegroup\svc-deploy", $sec)

              $script = {
                param($pkg, $siteName, $appPool, $hostHeader, $httpPort, $enableHttps, $httpsPort, $thumb, $physicalPath)
                $ErrorActionPreference = 'Stop'
                Import-Module WebAdministration

                $bindHttp  = "*:${httpPort}:${hostHeader}"
                $bindHttps = "*:${httpsPort}:${hostHeader}"

                if (-not (Test-Path "IIS:\AppPools\$appPool")) { New-Item "IIS:\AppPools\$appPool" | Out-Null }
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name managedRuntimeVersion -Value ""
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name startMode -Value "AlwaysRunning"
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name recycling.periodicRestart.time -Value ([TimeSpan]::Zero)

                if (-not (Test-Path $physicalPath)) { New-Item -ItemType Directory -Path $physicalPath -Force | Out-Null }

                if (-not (Test-Path "IIS:\Sites\$siteName")) {
                  New-Item "IIS:\Sites\$siteName" -physicalPath $physicalPath -bindings @{ protocol='http'; bindingInformation=$bindHttp } | Out-Null
                }

                $hasHttp = Get-WebBinding -Name $siteName -Protocol http | Where-Object { $_.bindingInformation -like $bindHttp }
                if (-not $hasHttp) { New-WebBinding -Name $siteName -Protocol http -Port $httpPort -HostHeader $hostHeader | Out-Null }

                if ($enableHttps -and -not [string]::IsNullOrWhiteSpace($thumb)) {
                  $hasHttps = Get-WebBinding -Name $siteName -Protocol https | Where-Object { $_.bindingInformation -like $bindHttps }
                  if (-not $hasHttps) { New-WebBinding -Name $siteName -Protocol https -Port $httpsPort -HostHeader $hostHeader | Out-Null }
                  $bindingPath = "IIS:\SslBindings\!${httpsPort}!${hostHeader}"
                  if (-not (Test-Path $bindingPath)) { New-Item $bindingPath -Thumbprint $thumb -SSLFlags 1 | Out-Null }
                  else { Set-Item $bindingPath -Thumbprint $thumb -SSLFlags 1 }
                }

                Set-ItemProperty "IIS:\Sites\$siteName" -Name applicationPool -Value $appPool

                Write-Host "Stopping application pool: $appPool"
                Stop-WebAppPool -Name $appPool -ErrorAction SilentlyContinue
                Write-Host "Stopping website: $siteName"
                Stop-Website -Name $siteName -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 5

                $msdeploy = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
                if (-not (Test-Path $msdeploy)) { throw "msdeploy not found at: $msdeploy" }

                $setParam = "-setParam:name=`"IIS Web Application Name`",value=`"$siteName`""
                & $msdeploy -verb:sync "-source:package=$pkg" "-dest:auto,computerName=localhost,authType=NTLM" $setParam -disableLink:AppPoolExtension -disableLink:ContentExtension -disableLink:CertificateExtension
              }

              Invoke-Command -ComputerName 'sit-server.dceg.co.za' -Credential $cred -ScriptBlock $script -ArgumentList $pkgRemote, $siteName, $appPool, $hostHeader, $httpPort, $enableHttps, $httpsPort, $thumb, $physicalPath

# ===== Approve UAT =====
- stage: Approve_UAT
  displayName: "Approve UAT"
  dependsOn: Deploy_SIT
  jobs:
  - job: WaitForApproval_UAT
    pool: server
    steps:
    - task: ManualValidation@0
      inputs:
        instructions: 'Approve deploy to UAT'
        notifyUsers: 'antonr@dcegroup.co.za'
        onTimeout: 'reject'
      timeoutInMinutes: 1440

# ===== CD: UAT =====
- stage: Deploy_UAT
  displayName: Deploy to UAT
  dependsOn: Approve_UAT
  condition: succeeded()
  jobs:
  - deployment: DeployToUAT
    environment: 'UAT'
    pool: { name: Default }
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: WindowsMachineFileCopy@2
            displayName: 'Copy package to target machine'
            inputs:
              SourcePath: '$(Pipeline.Workspace)\drop\WebApp.zip'
              MachineNames: 'uat-server.dceg.co.za'
              AdminUserName: 'dcegroup\svc-deploy'
              AdminPassword: '$(deploy_password)'
              TargetPath: 'C:\Temp\$(Build.BuildId)'

          - powershell: |
              $ErrorActionPreference = 'Stop'

              $pkgRemote = "C:\Temp\$($env:BUILD_BUILDID)\WebApp.zip"
              $siteName     = 'uat.dceg.co.za'
              $appPool      = 'uat.dceg.co.za'
              $hostHeader   = 'uat.dceg.co.za'
              $httpPort     = 80
              $enableHttps  = $false
              $httpsPort    = 443
              $thumb        = ''
              $physicalPath = 'C:\Sites\uat.dceg.co.za'

              $sec = ConvertTo-SecureString "$(deploy_password)" -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential ("dcegroup\svc-deploy", $sec)

              $script = {
                param($pkg, $siteName, $appPool, $hostHeader, $httpPort, $enableHttps, $httpsPort, $thumb, $physicalPath)
                $ErrorActionPreference = 'Stop'
                Import-Module WebAdministration

                $bindHttp  = "*:${httpPort}:${hostHeader}"
                $bindHttps = "*:${httpsPort}:${hostHeader}"

                if (-not (Test-Path "IIS:\AppPools\$appPool")) { New-Item "IIS:\AppPools\$appPool" | Out-Null }
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name managedRuntimeVersion -Value ""
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name startMode -Value "AlwaysRunning"
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name recycling.periodicRestart.time -Value ([TimeSpan]::Zero)

                if (-not (Test-Path $physicalPath)) { New-Item -ItemType Directory -Path $physicalPath -Force | Out-Null }

                if (-not (Test-Path "IIS:\Sites\$siteName")) {
                  New-Item "IIS:\Sites\$siteName" -physicalPath $physicalPath -bindings @{ protocol='http'; bindingInformation=$bindHttp } | Out-Null
                }

                $hasHttp = Get-WebBinding -Name $siteName -Protocol http | Where-Object { $_.bindingInformation -like $bindHttp }
                if (-not $hasHttp) { New-WebBinding -Name $siteName -Protocol http -Port $httpPort -HostHeader $hostHeader | Out-Null }

                if ($enableHttps -and -not [string]::IsNullOrWhiteSpace($thumb)) {
                  $hasHttps = Get-WebBinding -Name $siteName -Protocol https | Where-Object { $_.bindingInformation -like $bindHttps }
                  if (-not $hasHttps) { New-WebBinding -Name $siteName -Protocol https -Port $httpsPort -HostHeader $hostHeader | Out-Null }
                  $bindingPath = "IIS:\SslBindings\!${httpsPort}!${hostHeader}"
                  if (-not (Test-Path $bindingPath)) { New-Item $bindingPath -Thumbprint $thumb -SSLFlags 1 | Out-Null }
                  else { Set-Item $bindingPath -Thumbprint $thumb -SSLFlags 1 }
                }

                Set-ItemProperty "IIS:\Sites\$siteName" -Name applicationPool -Value $appPool

                Write-Host "Stopping application pool: $appPool"
                Stop-WebAppPool -Name $appPool -ErrorAction SilentlyContinue
                Write-Host "Stopping website: $siteName"
                Stop-Website -Name $siteName -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 5

                $msdeploy = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
                if (-not (Test-Path $msdeploy)) { throw "msdeploy not found at: $msdeploy" }

                $setParam = "-setParam:name=`"IIS Web Application Name`",value=`"$siteName`""
                & $msdeploy -verb:sync "-source:package=$pkg" "-dest:auto,computerName=localhost,authType=NTLM" $setParam -disableLink:AppPoolExtension -disableLink:ContentExtension -disableLink:CertificateExtension
              }

              Invoke-Command -ComputerName 'uat-server.dceg.co.za' -Credential $cred -ScriptBlock $script -ArgumentList $pkgRemote, $siteName, $appPool, $hostHeader, $httpPort, $enableHttps, $httpsPort, $thumb, $physicalPath

# ===== Approve Prod =====
- stage: Approve_Prod
  displayName: "Approve Prod"
  dependsOn: Deploy_UAT
  jobs:
  - job: WaitForApproval_Prod
    pool: server
    steps:
    - task: ManualValidation@0
      inputs:
        instructions: 'Approve deploy to Prod'
        notifyUsers: 'antonr@dcegroup.co.za'
        onTimeout: 'reject'
      timeoutInMinutes: 1440

# ===== CD: Prod =====
- stage: Deploy_Prod
  displayName: Deploy to Prod
  dependsOn: Approve_Prod
  condition: succeeded()
  jobs:
  - deployment: DeployToProd
    environment: 'Prod'
    pool: { name: Default }
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: WindowsMachineFileCopy@2
            displayName: 'Copy package to target machine'
            inputs:
              SourcePath: '$(Pipeline.Workspace)\drop\WebApp.zip'
              MachineNames: 'prod-server.dceg.co.za'
              AdminUserName: 'dcegroup\svc-deploy'
              AdminPassword: '$(deploy_password)'
              TargetPath: 'C:\Temp\$(Build.BuildId)'

          - powershell: |
              $ErrorActionPreference = 'Stop'

              $pkgRemote = "C:\Temp\$($env:BUILD_BUILDID)\WebApp.zip"
              $siteName     = 'dceg.co.za'
              $appPool      = 'dceg.co.za'
              $hostHeader   = 'dceg.co.za'
              $httpPort     = 80
              $enableHttps  = $false
              $httpsPort    = 443
              $thumb        = ''
              $physicalPath = 'C:\Sites\dceg.co.za'

              $sec = ConvertTo-SecureString "$(deploy_password)" -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential ("dcegroup\svc-deploy", $sec)

              $script = {
                param($pkg, $siteName, $appPool, $hostHeader, $httpPort, $enableHttps, $httpsPort, $thumb, $physicalPath)
                $ErrorActionPreference = 'Stop'
                Import-Module WebAdministration

                $bindHttp  = "*:${httpPort}:${hostHeader}"
                $bindHttps = "*:${httpsPort}:${hostHeader}"

                if (-not (Test-Path "IIS:\AppPools\$appPool")) { New-Item "IIS:\AppPools\$appPool" | Out-Null }
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name managedRuntimeVersion -Value ""
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name startMode -Value "AlwaysRunning"
                Set-ItemProperty "IIS:\AppPools\$appPool" -Name recycling.periodicRestart.time -Value ([TimeSpan]::Zero)

                if (-not (Test-Path $physicalPath)) { New-Item -ItemType Directory -Path $physicalPath -Force | Out-Null }

                if (-not (Test-Path "IIS:\Sites\$siteName")) {
                  New-Item "IIS:\Sites\$siteName" -physicalPath $physicalPath -bindings @{ protocol='http'; bindingInformation=$bindHttp } | Out-Null
                }

                $hasHttp = Get-WebBinding -Name $siteName -Protocol http | Where-Object { $_.bindingInformation -like $bindHttp }
                if (-not $hasHttp) { New-WebBinding -Name $siteName -Protocol http -Port $httpPort -HostHeader $hostHeader | Out-Null }

                if ($enableHttps -and -not [string]::IsNullOrWhiteSpace($thumb)) {
                  $hasHttps = Get-WebBinding -Name $siteName -Protocol https | Where-Object { $_.bindingInformation -like $bindHttps }
                  if (-not $hasHttps) { New-WebBinding -Name $siteName -Protocol https -Port $httpsPort -HostHeader $hostHeader | Out-Null }
                  $bindingPath = "IIS:\SslBindings\!${httpsPort}!${hostHeader}"
                  if (-not (Test-Path $bindingPath)) { New-Item $bindingPath -Thumbprint $thumb -SSLFlags 1 | Out-Null }
                  else { Set-Item $bindingPath -Thumbprint $thumb -SSLFlags 1 }
                }

                Set-ItemProperty "IIS:\Sites\$siteName" -Name applicationPool -Value $appPool

                Write-Host "Stopping application pool: $appPool"
                Stop-WebAppPool -Name $appPool -ErrorAction SilentlyContinue
                Write-Host "Stopping website: $siteName"
                Stop-Website -Name $siteName -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 5

                $msdeploy = "C:\Program Files\IIS\Microsoft Web Deploy V3\msdeploy.exe"
                if (-not (Test-Path $msdeploy)) { throw "msdeploy not found at: $msdeploy" }

                $setParam = "-setParam:name=`"IIS Web Application Name`",value=`"$siteName`""
                & $msdeploy -verb:sync "-source:package=$pkg" "-dest:auto,computerName=localhost,authType=NTLM" $setParam -disableLink:AppPoolExtension -disableLink:ContentExtension -disableLink:CertificateExtension
              }

              Invoke-Command -ComputerName 'prod-server.dceg.co.za' -Credential $cred -ScriptBlock $script -ArgumentList $pkgRemote, $siteName, $appPool, $hostHeader, $httpPort, $enableHttps, $httpsPort, $thumb, $physicalPath
